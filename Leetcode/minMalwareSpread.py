import collections

class Solution(object):
    def minMalwareSpread(self, graph, initial):
        # 1. Color each component.
        # colors[node] = the color of this node.
        # subgraph a node belongs to
        import pdb; pdb.set_trace()
        N = len(graph)
        colors = {}     # {0: 0, 1: 0, 2: 1}
        c = 0

        def dfs(node, color):
            colors[node] = color
            for nei, adj in enumerate(graph[node]):
                if adj and nei not in colors:
                    dfs(nei, color)

        for node in range(N):
            if node not in colors:
                dfs(node, c)
                c += 1

        # 2. Size of each color.
        # size[color] = number of occurrences of this color.
        # size of each subgraph. number of nodes in each subgraph
        # Counter({0: 2, 1: 1})
        size = collections.Counter(colors.values())

        # 3. Find unique colors.
        # Number of infected nodes in a subgraph
        # Counter({0: 2})
        color_count = collections.Counter()
        for node in initial:
            color_count[colors[node]] += 1

        # 4. Answer
        ans = float('inf')
        for x in initial:
            c = colors[x]
            # if num of infected nodes in subgraph is 1
            if color_count[c] == 1:
                if ans == float('inf'):
                    ans = x
                # if number of nodes in subgraph that x belongs is greater
                elif size[c] > size[colors[ans]]:
                    ans = x
                # if number of nodes in subgraph that x belongs is equal
                # choose the smaller index
                elif size[c] == size[colors[ans]] and x < ans:
                    ans = x
        return ans if ans < float('inf') else min(initial) 

    def minMalwareSpread_2(self, graph, initial):
        N = len(graph)
        import pdb; pdb.set_trace()
        # clean nodes
        clean = set(range(N)) - set(initial)
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)

            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.
        contribution = collections.Counter()
        for v, neighbors in infected_by.items():
            if len(neighbors) == 1:
                contribution[neighbors[0]] += 1

        # Take the best answer.
        best = (-1, min(initial))
        for u, score in contribution.items():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u
        return best[1]

if __name__ == "__main__":
    g = [[1,1,0],[1,1,0],[0,0,1]]
    i = [0, 1]
    print(Solution().minMalwareSpread_2(g, i))
